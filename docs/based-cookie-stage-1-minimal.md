---
name: based-cookie-stage-1-minimal
stage: 1
title: Этап 1 — минимальные изменения с максимальным эффектом
overview: Детализированная карта работ для первого этапа развития мини‑аппа Based Cookie с фокусом на UX транзакций, минимальной персонализации по FID и базовом серверном учёте кулдауна.
---

## Как читать этот файл

- **Для чего**: это "технический сценарий" именно для реализации **этапа 1**. Он помогает не потеряться в деталях, не сломать уже работающие части и опираться на существующую документацию.
- **Кому**: и тебе, и ИИ‑агенту. Здесь прямо подсвечены:
  - какие файлы трогать;
  - на какие доки смотреть;
  - какие типичные ошибки и ловушки бывает легко допустить.
- **Как использовать**:
  - Перед началом работ по этому этапу — пробежать файл целиком.
  - При просьбе "сделать что‑то вне плана" — сначала свериться с разделами "Чего не делать" и "Типичные ошибки".

---

## Цели этапа 1

- **Сделать UX транзакций и ошибок "острым" и понятным**, не меняя форматы API и контракт.
- **Добавить минимальную персонализацию по Farcaster FID** без тяжёлого backend.
- **Перенести кулдаун с чисто клиентского состояния на простую серверную опору**, но без полноценной истории/лидерборда.
- **Улучшить конфигурацию Paymaster** так, чтобы не ломать текущие деплои.

---

## Охват по файлам

- **Фронтенд**:
  - `app/page.tsx` — основной экран мини‑аппа, логика UX, транзакций и кулдауна.
- **Backend / API**:
  - `app/api/auth/route.ts` — уже существующий эндпоинт авторизации по Farcaster JWT.
  - Новый/расширенный эндпоинт `GET /api/fortune/status` — серверный статус кулдауна и сегодняшней фортуны.
  - Новый/расширенный эндпоинт `POST /api/fortune/claim` — фиксация успешного клейма.
- **Инфраструктура / конфиг**:
  - `app/paymaster.ts` — резолвинг URL Paymaster и профили окружений.
  - `.env` / `.env.local` — переменные окружения для разных профилей Paymaster.
- **Документация**:
  - `docs/miniapp-endpoints.md` — источник правды по контрактам API (`/api/auth`, `/api/fortune/status`, `/api/fortune/claim`).
  - `memory.md` — зафиксированные архитектурные решения (paymaster, контракт, metadata, cooldown).

---

## Подробный план работ

### 1. Улучшенный UX статусов транзакций и ошибок

- **Опора на текущий код**:
  - В `memory.md` уже описаны:
    - тип `LifecycleStatus`;
    - функция `handleTxStatus(status)` в `app/page.tsx`;
    - схема нотификаций `TxNotice` и оверлей внизу экрана.
- **Что добавить**:
  - **Более детальный разбор статусов**:
    - **отдельный кейс "отмена пользователем"** — когда пользователь закрыл модалку, отказался подписывать или прервал flow;
    - **ошибки paymaster** — коды типа `-32002`, `403/500/502` от `/api/paymaster`;
    - **ошибки лимитов и кулдауна** — сценарии, когда backend вернёт, например, `COOLDOWN_ACTIVE`.
  - **Тексты нотификаций**:
    - использовать короткие, но информативные сообщения (в русской/английской версии — договориться заранее);
    - в ошибках подсказывать следующее действие (повторить позже, проверить кошелёк, обратиться в поддержку и т.п.).
- **Типичные ошибки**:
  - **Смешивание ончейн‑ошибок и backend‑ошибок**:
    - Не пытаться "парсить" каждую ошибку по строке; лучше смотреть на структурированные поля статуса (`statusName`, presence `txHash`) и HTTP‑коды для запросов к backend.
  - **Лишний state / дублирование**:
    - Не дублировать в state то, что уже можно вычислить (например, `isCooldownActive` — либо из backend, либо из текущего `cooldownEndsAt`).
- **Практический совет**:
  - Для обработки ошибок **после ончейн‑транзакции** использовать pattern:
    - если `status.statusName === 'error'` и есть `status.errorName` или `status.errorCode`, маппить их на дружелюбный текст;
    - если при success вызов `POST /api/fortune/claim` вернул `400/409` — показывать отдельный UX для "сервер не принял клейм" (например, дубль, кулдаун).

---

### 2. Минимальная персонализация по FID без тяжёлого backend

- **На что опираемся**:
  - `GET /api/auth` из `docs/miniapp-endpoints.md`:
    - возвращает `{ userFid: number }` при корректном Farcaster JWT.
  - Mini App Quick Auth:
    - все запросы к приватным эндпоинтам должны идти через `sdk.quickAuth.fetch`, чтобы заголовок `Authorization: Bearer <jwt>` подставлялся автоматически.
- **Идея реализации**:
  - Получаем `userFid` один раз после монтажа компонента (или лениво при первом обращении).
  - В `app/page.tsx` сохраняем `userFid` в state.
  - Для сегодняшней фортуны:
    - используем **детерминированный выбор** на клиенте:
      - строка вида `"fid:<FID>:date:<YYYY-MM-DD>"`;
      - берём хэш (например, `xxhash32` или простой JS‑хэш) и маппим его на индекс в массиве `FORTUNES[]`;
    - это даёт "ежедневную" фортуны на пользователя без хранения на сервере.
- **Типичные ошибки**:
  - **Не использовать `sdk.quickAuth.fetch`**:
    - если отправить `fetch('/api/auth')` напрямую, JWT не попадёт в заголовки → backend вернёт `401`.
  - **Привязка к локальному времени**:
    - если использовать локальную таймзону, пользователи в разных часовых поясах могут получать "две" разные фортуны в течение одних и тех же UTC‑суток;
    - лучше использовать либо UTC (дата по UTC), либо явно зафиксированную таймзону (и документировать это).
- **Практический совет**:
  - При реализации хэша:
    - избегать нестабильных вариантов (например, сортировка по `Math.random()` или завязка на порядок массива `FORTUNES`, который потом меняется);
    - хранить функцию выбора фортуны в отдельном helper‑модуле, чтобы можно было переиспользовать её затем на backend при развитии системы.

---

### 3. Базовый серверный учёт кулдауна и успешных клеймов (учёт Vercel)

- **Минимальный скоп для этапа 1**:
  - Реализовать **упрощённые** версии:
    - `GET /api/fortune/status` — возвращает только:
      - `user: UserId`;
      - `lastClaimAt?`;
      - `nextClaimAvailableAt?`;
      - `isCooldownActive`;
      - `remainingCooldownMs`.
    - `POST /api/fortune/claim` — валидация кулдауна + запись факта клейма (хотя бы in‑memory или файл).
- **Хранилище**:
  - Для этапа 1 можно использовать **только dev‑варианты**, помня про Vercel:
    - in‑memory map — допустимо локально, но **нестабильно** на Vercel (много инстансов функций, холодные старты, стейт не шарится);
    - JSON‑файл на диске — на Vercel файловая система по сути read‑only, запись не гарантируется (кроме `/tmp` и только на один инстанс).
  - Вывод: на этапе 1 серверный учёт кулдауна — это **прототип контракта API**, а не готовое прод‑хранилище. В проде (на Vercel) всё равно нужна внешняя БД (Supabase/Neon/PlanetScale и т.п.), что будет реализовано на этапе 2.
- **Критичные нюансы для Vercel**:
  - **Стейт и масштабирование**:
    - любая логика должна быть **stateless по запросу** — нельзя полагаться на то, что следующее обращение попадёт в тот же процесс функции;
    - любые данные, которые важны "между запросами", должны жить во внешнем хранилище.
  - **База данных наперёд**:
    - уже на этапе 1 стоит проектировать модели (`FortuneClaim`, `UserStats`, `FortuneStatus`) так, чтобы их потом было легко перенести в Postgres/другую БД;
    - не "подгонять" API под временное in‑memory хранилище.
  - **Согласованность с фронтом**:
    - важно вернуть поля с именами и типами **строго как в `docs/miniapp-endpoints.md`**, чтобы не ломать дальнейшее расширение;
    - не стоит "экономить" на полях, которые уже описаны и понадобятся на этапе 2 (`FortuneStatus`), даже если сейчас они не используются.
- **Типичные ошибки**:
  - **Двойной источник правды по кулдауну**:
    - Нельзя, чтобы клиент считал кулдаун по своему локальному таймеру, а сервер по своему — без периодической синхронизации;
    - правильный подход: сервер возвращает `nextClaimAvailableAt`, клиент пересчитывает `isCooldownActive`/`remainingCooldownMs` локально, но при важных действиях (открытие приложения, успешный клейм) обновляет статус с сервера.
  - **Формат времени**:
    - всегда использовать ISO‑строки (`new Date().toISOString()`), как и описано в моделях `FortuneClaim`/`FortuneStatus`.

---

### 4. Paymaster профили и dev‑конфигурация

- **Точка входа**:
  - В `memory.md` уже описаны:
    - `getClientPaymasterUrl()` и логика нормализации относительных/абсолютных URL (`/api/paymaster` → абсолютный URL).
  - На этапе 1 важно **не сломать** текущий рабочий путь.
- **Что добавить**:
  - Сразу думать с учётом **двух сетей** и Vercel‑окружений:
    - dev / preview деплои на Vercel → ориентируем на **Base Sepolia**;
    - production деплой → ориентируем на **Base mainnet**.
  - Завести несколько env‑переменных для профилей:
    - `NEXT_PUBLIC_BASE_NETWORK=sepolia|mainnet` — текущая выбранная сеть в фронте;
    - `NEXT_PUBLIC_PAYMASTER_SEPOLIA_URL`
    - `NEXT_PUBLIC_PAYMASTER_MAINNET_URL`
    - (опционально: отдельные адреса контракта по сетям, будут использованы на следующих этапах).
  - В `app/paymaster.ts`:
    - небольшая функция, которая по `NEXT_PUBLIC_BASE_NETWORK` выбирает нужный URL;
    - при отсутствии конкретного профиля — fallback на уже существующий `NEXT_PUBLIC_PAYMASTER_PROXY_SERVER_URL`.
- **Типичные ошибки**:
  - **Жёсткое зашивание URL в код**:
    - не вписывать конкретные endpoint‑ы Paymaster прямо в `app/page.tsx` или другие компоненты;
    - всегда идти через `getClientPaymasterUrl()` / конфиг‑функции.
  - **Нарушение инвариантов paymaster_proxy_server_side** (см. `memory.md`):
    - proxy должен принимать только `pm_*` методы;
    - URL должен резолвиться на сервере из `CDP_PAYMASTER_URL`, не "утекать" напрямую в клиентскую конфигурацию.

---

## Чего не делать на этапе 1

- **Не менять ABI контракта и адрес**:
  - никаких изменений в `app/contract.ts`, если только не исправляется очевидная ошибка;
  - не менять `DEFAULT_CONTRACT_ADDRESS` и логику резолвинга адреса через env.
- **Не внедрять сразу тяжёлую БД или NFT‑минт**:
  - можно наметить схемы и интерфейсы, но реализацию ончейн‑редкостей/сет‑коллекций оставить на **этап 3**.
- **Не переписывать глобальные провайдеры**:
  - `app/rootProvider.tsx` и MiniKit‑интеграцию трогать только минимально (если потребуется добавить контекст для FID/статуса).

---

## Подсказки, если появятся запросы "вне плана"

- **Если попросят "добавить NFT‑минт" на этом этапе**:
  - Ответ: это функционал **этапа 3**. На этапе 1 можно только:
    - спроектировать структуры данных и эндпоинты;
    - добавить комментарии/заглушки, не меняя ончейн‑контракт.
- **Если попросят "сделать сразу лидерборд"**:
  - Ответ: лидерборды принадлежат **этапу 2**. Сейчас можно:
    - аккуратно расширить `UserStats`;
    - но не делать публичные `GET /api/leaderboard` и сложную агрегацию.
- **Если попросят "вынести всё состояние фортуны на сервер"**:
  - На этапе 1 допустим только **частичный** вынос (кулдаун + факт клейма).
  - Полная daily‑логика, streak и история должны быть реализованы по спецификации в `docs/miniapp-endpoints.md` уже на этапе 2.

---

## Краткий чеклист перед merge этапа 1

- **Функциональность**:
  - UX транзакций: понятные статусы и сообщения, без регрессий.
  - Персонализация: фортуны зависят от FID и дня (проверить на 2–3 тестовых FID).
  - Кулдаун: после успешного клейма сервер возвращает ожидаемое `nextClaimAvailableAt`, клиент корректно показывает время до следующей печеньки.
- **Безопасность и ошибки**:
  - Все новые приватные эндпоинты вызываются через `sdk.quickAuth.fetch`.
  - Форматы ответов соответствуют `docs/miniapp-endpoints.md` (без "самодеятельности" в полях).
- **Конфигурация**:
  - При отсутствии новых env‑переменных Paymaster поведение не ломается и использует старый путь.


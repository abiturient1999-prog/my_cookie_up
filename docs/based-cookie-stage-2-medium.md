---
name: based-cookie-stage-2-medium
stage: 2
title: Этап 2 — серверная логика, история, лидерборды и шаринг
overview: Детализированная карта работ для второго этапа развития мини‑аппа Based Cookie с фокусом на полноценном API, истории фортуны, лидербордах и share-страницах.
---

## Как читать этот файл

- **Для чего**: это технический сценарий реализации **этапа 2**, когда у нас уже есть минимальный серверный кулдаун и персонализация (этап 1), и мы хотим построить "настоящий" продуктовый слой (история, лидерборды, шаринг).
- **Кому**: и тебе, и ИИ‑агенту. Здесь подчёркнуты:
  - зависимости от этапа 1;
  - места, где легко сломать контракт с фронтом или нарушить инварианты API.

---

## Цели этапа 2

- **Реализовать полноценный daily‑flow и streak** на сервере по спецификациям в `docs/miniapp-endpoints.md` и `based-cookie-gamification-ideas.md`.
- **Добавить историю фортуны (history‑страницу)** с пагинацией.
- **Сделать рабочие лидерборды** на основе агрегированной статистики пользователей.
- **Ввести share‑страницы с публичными данными по конкретному клейму** и OG‑метаданными для Warpcast.
- **Привести Mini App UX к "завершённому" состоянию**: логичный flow от открытия до клейма, истории, лидерборда и шаринга.

---

## Охват по файлам

- **Фронтенд**:
  - `app/page.tsx` — интеграция с новыми эндпоинтами (`/api/fortune/status`, `/api/fortune/claim`), навигация.
  - `app/history/page.tsx` — новый экран истории фортуны.
  - `app/leaderboard/page.tsx` — новый экран лидербордов.
  - `app/share/[claimId]/page.tsx` — новый экран share‑страниц.
- **Backend / API**:
  - `app/api/auth/route.ts` — уже готовый; используется в новых эндпоинтах для получения `userFid`.
  - `app/api/fortune/status` — реализация по полной спецификации `FortuneStatus`.
  - `app/api/fortune/claim` — реализация по полной спецификации `FortuneClaim` + обновление `UserStats`.
  - `app/api/fortune/history` — история клеймов с пагинацией.
  - `app/api/leaderboard` — публичный/полупубличный лидерборд.
  - `app/api/share/[claimId]` — публичные данные по конкретному клейму.
- **Документация / модели**:
  - `docs/miniapp-endpoints.md` — источник правды по моделям `FortuneDefinition`, `FortuneClaim`, `UserStats`, `FortuneStatus`.
  - `based-cookie-gamification-ideas.md` — поведенческие детали (streak, редкости, коллекции).
  - `docs/based-cookie-stage-1-minimal.md` — что уже реализовано и как не сломать.

---

## Подробный план работ

### 1. Модели данных и источник правды (учёт Vercel и двух сетей)

- **Основные модели** (см. `docs/miniapp-endpoints.md`):
  - `UserId` — пара `(fid, address)`.
  - `FortuneDefinition` — справочник всех возможных фортуны.
  - `FortuneClaim` — одна запись о клейме.
  - `UserStats` — агрегированная статистика.
  - `FortuneStatus` — текущий "ежедневный" статус пользователя.
- **С чего начать**:
  - Реализовать/зафиксировать **справочник фортуны**:
    - как минимум массив/таблицу `FortuneDefinition[]` в отдельном модуле (например, `app/fortune/definitions.ts` или `lib/fortune/definitions.ts`);
    - использовать его и на backend, и на frontend (избегать копипасты списка фортуны).
  - Спроектировать **хранилище с учётом Vercel и Neon**:
    - на этом этапе желательно перейти с in‑memory/файла на внешнюю БД:
      - **Neon Serverless Postgres** как основной вариант (уже подключён в проект);
      - альтернативы — Supabase/PlanetScale, если когда‑нибудь потребуется миграция.
    - для Neon:
      - использовать endpoint с `-pooler` в хосте (PgBouncer‑pooling, см. `connection-pooling` в Neon docs);
      - для Node/Fluid compute можно использовать либо стандартный `pg` + pooler‑endpoint, либо серверлесс‑драйвер `@neondatabase/serverless` (HTTP/WebSocket).
    - при использовании Edge‑окружения:
      - использовать только HTTP‑совместимые драйверы (например, `@neondatabase/serverless`), не TCP‑клиенты.
    - для серверных функций Next.js на Vercel:
      - предпочитать Node/Fluid compute для БД‑нагруженных запросов (Route Handlers по умолчанию), а не Edge Functions;
      - использовать connection pooling и best practices из гайдов Vercel (`@vercel/functions` и аналогичные утилиты), не открывать новый TCP‑коннект на каждый запрос.
  - Сразу учесть **две сети (Base Sepolia / Base mainnet)**:
    - в моделях стоит иметь поле `network: 'sepolia' | 'mainnet'` либо разнести данные по схемам/таблицам;
    - на уровне конфигов использовать env‑переменные:
      - `NEXT_PUBLIC_BASE_NETWORK` для фронта;
      - `BASE_NETWORK`/`DB_SCHEMA` или аналогичный флаг для backend, чтобы не смешивать тестовые и боевые данные в одной таблице.
- **Типичные ошибки**:
  - **Расхождение типов между кодом и docs**:
    - важно, чтобы TypeScript‑типы в коде (или `zod`‑схемы) **строго** соответствовали моделям из `docs/miniapp-endpoints.md`;
    - любые изменения сначала вносятся в doc, потом в код, а не наоборот.

---

### 2. Полноценный daily‑flow и streak на сервере

- **Логика из `based-cookie-gamification-ideas.md` (раздел "Daily‑flow, кулдаун и streak")**:
  - `lastClaimAt`, `dailyStreak`, `totalClaims` на пользователя `(fid, address)`.
  - Кулдаун: нельзя выдавать новую фортуне, если с `lastClaimAt` прошло \< 24 часов.
  - Пропуск дня сбрасывает streak.
- **Что должно делать `GET /api/fortune/status`**:
  - На основе токена (`/api/auth`) и запроса:
    - определить `(fid, address)` (`address` приходит как query).
    - если у пользователя ещё не было клеймов:
      - сгенерировать `todaysFortune` детерминированно по `(fid, date)` и сохранить `todaysFortuneAssignedAt`;
    - если были клеймы:
      - рассчитать `currentStreakDays`, `bestStreakDays`, `totalClaims`;
      - определить, активен ли кулдаун (`isCooldownActive`) и до какого времени (`nextClaimAvailableAt`).
  - Вернуть структуру `FortuneStatus` в точности как в доке.
- **Что должно делать `POST /api/fortune/claim`**:
  - Проверить кулдаун:
    - если кулдаун активен — вернуть `400` с `code: "COOLDOWN_ACTIVE"`.
  - Убедиться, что `fortuneId` соответствует сегодняшней фортуне для пользователя.
  - Создать запись `FortuneClaim` (с ссылкой на `FortuneDefinition.id`).
  - Обновить `UserStats` (увеличить `totalClaims`, скорректировать `currentStreakDays`/`bestStreakDays`).
  - Вернуть:
    - `claim`;
    - `updatedStatus`;
    - `updatedStats`.
- **Фронтенд (app/page.tsx)**:
  - При монтировании:
    - получить `userFid` через `/api/auth`;
    - получить `address` из OnchainKit (`useAccount`);
    - вызвать `GET /api/fortune/status` через `sdk.quickAuth.fetch`.
  - При успешной транзакции:
    - в `handleTxStatus` при `statusName === 'success'` вызвать `POST /api/fortune/claim`;
    - обновить локальное состояние из `updatedStatus`/`updatedStats`.
- **Типичные ошибки**:
  - **Нарушение идемпотентности**:
    - нельзя допускать, чтобы при повторном вызове `POST /api/fortune/claim` (например, при retry на клиенте) записывался второй клейм за ту же транзакцию;
    - нужно либо хранить `txHash` и проверять дубликаты, либо использовать уникальные ключи на `(user, date)` и/или `(user, fortuneId, claimedAt)`.
  - **Игнорирование Vercel‑архитектуры**:
    - нельзя рассчитывать на in‑memory счётчики/кэш для streak/кулдауна — любая логика должна опираться на внешнее хранилище (БД, KV и т.п.);
    - все серверные функции (`/api/fortune/*`) должны быть idempotent и устойчивы к повторным вызовам и холодным стартам.

---

### 3. История фортуны — `GET /api/fortune/history` и `app/history/page.tsx`

- **API** (см. `docs/miniapp-endpoints.md`):
  - `GET /api/fortune/history`:
    - Query:
      - `address: 0x...` (обязательно).
      - `limit?: number`, `offset?: number`.
    - Ответ:
      - `items: Array<FortuneClaim & { fortune: FortuneDefinition }>`;
      - `total: number`;
      - `hasMore: boolean`.
- **Backend реализация**:
  - Эффективная пагинация:
    - при хранении в БД — использовать индекс по `(address, claimedAt DESC)`;
    - `LIMIT/OFFSET` или keyset‑пагинация (по `claimedAt`/`id`).
  - Защита:
    - аутентификация через Farcaster JWT (`sdk.quickAuth.fetch`);
    - проверка, что пользователь запрашивает **свою** историю (`fid` из токена + адрес из query).
  - Vercel‑специфика:
    - для тяжёлых запросов истории использовать обычные серверные функции (Node/Fluid compute), а не Edge Functions, чтобы не упираться в ограничения драйверов БД и сетевой задержки до БД;
    - если всё‑таки нужен Edge‑вариант, использовать HTTP‑драйверы (Neon, PlanetScale, Prisma Postgres/Accelerate), а не прямые TCP‑клиенты (`pg`, `mysql2` и т.п.).
- **Фронтенд (`app/history/page.tsx`)**:
  - Отображать список:
    - текст фортуны;
    - дата/время клейма;
    - редкость (на этом этапе можно использовать `common/rare/legendary`, даже если они пока не привязаны к контракту).
  - Поддержка пагинации:
    - кнопка "Загрузить ещё" или infinite scroll.
- **Типичные ошибки**:
  - **Путаница между FID и адресом**:
    - авторизация идёт по FID, но фильтрация истории — по адресу;
    - важно не дать пользователю посмотреть чужую историю, просто подставив другой `address` в query.

---

### 4. Лидерборды — `GET /api/leaderboard` и `app/leaderboard/page.tsx`

- **API**:
  - `GET /api/leaderboard`:
    - Query:
      - `metric: 'totalClaims' | 'rareClaims' | 'legendaryClaims'`;
      - `limit?: number`.
    - Ответ:
      - `items: Array<{ user: UserId; rank: number; stats: UserStats }>`;
      - `metric: string`.
- **Backend реализация**:
  - Агрегация:
    - если есть БД — агрегаты по клеймам (COUNT, SUM по редкостям и т.п.);
    - опционально периодический пересчёт (cron/job) для масштабирования.
  - Публичность:
    - по умолчанию можно сделать эндпоинт публичным (без JWT), так как данные аггрегированы и не содержат чувствительной информации;
    - если требуется privacy, можно ограничить доступ и/или анонимизировать часть данных.
- **Фронтенд (`app/leaderboard/page.tsx`)**:
  - Табы/переключатели по `metric`.
  - Таблица top‑N пользователей:
    - FID/handle, возможно аватар;
    - ключевые числа: `totalClaims`, `rareClaims`, `legendaryClaims`, `bestStreakDays`.
  - Подсветка текущего пользователя, если он входит в leaderboard.
- **Типичные ошибки**:
  - **Нестабильный порядок/ранги**:
    - при равных значениях метрики нужно иметь вторичный критерий сортировки (например, более ранний первый клейм получает больший ранг);
    - иначе при каждом запросе пользователь может "прыгать" по позициям.
  - **Тяжёлые запросы без индексов**:
    - если клеймов много, запросы без индекса по `metric`/`user` будут тормозить;
    - важно предусмотреть индексы или периодический precompute.

---

### 5. Share‑страницы — `GET /api/share/[claimId]` и `app/share/[claimId]/page.tsx`

- **API**:
  - `GET /api/share/[claimId]`:
    - Параметры:
      - `claimId` — идентификатор записи о клейме.
    - Ответ:
      - `claim: { id, fortune: FortuneDefinition, user: { fid }, claimedAt }`.
  - Эндпоинт обычно публичный.
- **Фронтенд**:
  - Страница `app/share/[claimId]/page.tsx`:
    - SSR/SSG по `claimId`;
    - отображение текста фортуны, редкости, базового контекста пользователя (FID, возможно handle).
  - OG‑метаданные:
    - использовать Next 15 `generateMetadata` / `ImageResponse` для динамической OG‑картинки;
    - картинка может включать текст фортуны, бейдж редкости и, опционально, дату/лейбл Based Cookie.
- **Интеграция с текущим шарингом (`handleShare` в `app/page.tsx`)**:
  - После успешного `POST /api/fortune/claim`:
    - получать `claim.id`;
    - генерировать ссылку на `/share/[claimId]`;
    - использовать её в Warpcast compose URL (через `sdk.actions.openUrl`).
- **Типичные ошибки**:
  - **Разглашение лишних данных**:
    - в share‑ответе и на странице лучше ограничиться FID и публичной информацией;
    - не возвращать/не выводить адрес кошелька без чёткой необходимости.
  - **Неправильное кеширование**:
    - share‑страницы и API могут кэшироваться внешними ботами/прокси, нужно либо:
      - сделать данные по клейму неизменяемыми;
      - либо явно управлять кэш‑заголовками.

---

### 6. Mini App‑специфичный UX

- **Цель**: сделать так, чтобы весь пользовательский путь внутри Farcaster Mini App был "плотным" и логичным:
  - открыть мини‑апп → увидеть сегодняшнюю фортуны и статус;
  - клейм → получить ончейн‑награду → увидеть обновлённый streak/кулдаун;
  - перейти в историю или лидерборд;
  - поделиться конкретной фортуны.
- **Точки интеграции**:
  - `sdk.actions.ready()` — своевременно сигнализировать Baseapp, когда UI готов.
  - `sdk.quickAuth.fetch` — единый способ аутентифицированных запросов к backend.
  - `sdk.actions.openUrl` — навигация на share‑страницы, внешний контент и т.п.
- **Типичные ошибки**:
  - **Смешивание обычного `fetch` и `sdk.quickAuth.fetch`**:
    - может приводить к "случайным" 401/403 в Mini App‑режиме, когда JWT не подставляется;
    - правило: все приватные эндпоинты всегда вызываются через quickAuth.

---

## Чего не делать на этапе 2

- **Не менять пока смарт‑контракт**:
  - весь функционал редкостей и NFT‑минта — территория **этапа 3**;
  - на этапе 2 можно хранить редкость и коллекции **off‑chain**, не кодируя их в контракте.
- **Не ломать контракты, принятые на этапе 1**:
  - формат ответов `GET /api/fortune/status` и `POST /api/fortune/claim` должен эволюционировать аккуратно;
  - старые поля не удаляются без версионирования (если нужен breaking change — обсуждать `/api/v2/...`).

---

## Подсказки, если появятся запросы "вне плана"

- **Если попросят "сделать NFT‑минт с share‑страницы"**:
  - Сейчас share‑страницы должны быть лёгкими и быстрыми, без тяжёлых onchain‑операций;
  - NFT‑минт — часть **этапа 3**, можно максимум добавить UX‑заглушку ("скоро").
- **Если попросят "сделать приватную историю"**:
  - По умолчанию история и так доступна только владельцу (через JWT);
  - дополнительно можно ограничить экспорт/шаринг, но это не должно ломать публичный контракт share‑страниц.

---

## Краткий чеклист перед merge этапа 2

- **API**:
  - Все эндпоинты из `docs/miniapp-endpoints.md` реализованы (status, claim, history, leaderboard, share).
  - Ответы соответствуют спецификации (типы, поля, коды ошибок).
- **Фронтенд**:
  - Главная страница корректно синхронизирует состояние с `GET /api/fortune/status`.
  - История и лидерборд работают, не раскрывая чужие данные.
  - Шаринг ведёт на рабочие share‑страницы с корректными OG‑метаданными.
- **Mini App**:
  - Все приватные запросы идут через `sdk.quickAuth.fetch`.
  - UX плавный: без "подвисаний" между шагами и с понятной индикацией состояний.


---
name: based-cookie-stage-3-advanced
stage: 3
title: Этап 3 — продвинутая ончейн-геймификация, NFT и AgentKit
overview: Детализированная карта работ для третьего этапа развития мини-аппа Based Cookie с фокусом на ончейн-редкостях, коллекциях, NFT-сувенирах и интеграции с AgentKit.
---

## Как читать этот файл

- **Для чего**: это сценарий для **самого рискованного и сложного этапа**, где изменения затрагивают смарт-контракт, ABI, ончейн-логику и "умный" UX.
- **Кому**: и тебе, и ИИ-агенту, чтобы:
  - не сломать уже работающий прод по ошибке в контракте или ABI;
  - не разрушить инварианты Mini App и API;
  - последовательно эволюционировать поверх этапов 1 и 2.

---

## Цели этапа 3

- **Расширить ончейн-контракт**:
  - добавить классы наград (`common/rare/legendary` и др.);
  - по необходимости кодировать `fortuneId`/атрибуты награды on-chain.
- **Добавить NFT-механику**:
  - возможность минтить "сувенирные" NFT по выбранным фортунам из истории.
- **Реализовать редкости, сеты и коллекции** в UI и backend:
  - "Meme Lord Set", "Onchain DeFi Set" и т.п.;
  - ачивки и прогресс по сетам.
- **Интегрировать AgentKit-подпример**:
  - chat/агент, умеющий запускать дополнительные on-chain-сценарии (донат, своп, NFT-операции), сохраняя лёгкий и безопасный UX.

---

## Охват по файлам

- **Смарт-контракт и ончейн-инфраструктура**:
  - репозиторий/папка с контрактом Based Cookie (вне этого Next.js-репо, но связана с ним).
  - адрес контракта и ABI — синхронизация с:
    - `app/contract.ts`;
    - `app/api/paymaster/route.ts` (таргетируемый `to`).
- **Backend / API**:
  - те же эндпоинты, что на этапе 2:
    - `/api/fortune/status`, `/api/fortune/claim`, `/api/fortune/history`, `/api/leaderboard`, `/api/share/[claimId]`;
  - плюс:
    - новые/расширенные эндпоинты для NFT-минта (например, `/api/nft/mint-fortune`) и коллекций.
- **Фронтенд**:
  - `app/page.tsx` — отображение редкостей, pity-таймера, прогресса по сетам, кнопки "заминтить".
  - `app/history/page.tsx` — NFT-операции из истории.
  - `app/leaderboard/page.tsx` — новые метрики (по NFT, сетам).
  - `Based Cookie/app/page.tsx` — AgentKit UI (чат/агент).

---

## Предварительные условия (что должно быть готово)

- Этап 1:
  - стабильный UX транзакций и ошибок;
  - базовый серверный кулдаун и учёт клеймов.
- Этап 2:
  - реализованы все основные эндпоинты (status, claim, history, leaderboard, share);
  - история и лидерборды работают и протестированы;
  - нет расхождений между кодом и `docs/miniapp-endpoints.md`.

Если что-то из этого не выполнено — **сначала привести в порядок этапы 1–2**, иначе любые ончейн-изменения будут сложно отлаживать.

---

## Подробный план работ

### 1. Расширение смарт-контракта и ABI

- **Идеи из `based-cookie-gamification-ideas.md`**:
  - "Редкости и коллекции фортуны":
    - каждой награде соответствует редкость (`COMMON`, `RARE`, `LEGENDARY`);
    - есть наборы/сеты, за которые даются бонусы.
  - "Ончейн-механики наград":
    - возможность кодировать редкость и, опционально, ссылку на `fortuneId` на уровне контракта.
- **Варианты реализации**:
  - Минимальный:
    - контракт хранит только класс награды (int/enum) и, возможно, какой-то seed;
    - off-chain-сервис маппит это на конкретную фортуне и UI-представление.
  - Продвинутый:
    - контракт хранит `fortuneId` или хэш текста;
    - контракт может минтить NFT с привязкой к этим данным.
- **Синхронизация с приложением**:
  - После любого изменения контракта необходимо:
    - обновить адрес и ABI в `app/contract.ts`;
    - убедиться, что paymaster/allowlist включают новый адрес и методы;
    - обновить тесты/скрипты, если они есть.
- **Типичные ошибки**:
  - **Несоответствие ABI**:
    - изменения в контракте без обновления ABI/адреса в Next-приложении;
    - использование старых селекторов методов (`claimReward`) при изменённой сигнатуре.
  - **Несогласованность с paymaster**:
    - новый адрес/метод не добавлен в allowlist paymaster → `-32002` и провал транзакций.

---

### 1.1. Деплой контрактов через Remix на Base Sepolia и Base mainnet

- **Опорные доки**:
  - документация Base по деплою через Remix (`deploy-with-remix`, `deployment-to-base-sepolia-sbs`);
  - документация Remix (`Deploy & Run` модуль).
- **Базовый pipeline деплоя**:
  - Открыть Remix (`remix.ethereum.org`) и импортировать контракт Based Cookie.
  - Выбрать нужную версию компилятора и параметры оптимизации — **зафиксировать их**, чтобы затем использовать при верификации на BaseScan.
  - В модуле `Deploy & Run`:
    - выбрать окружение `Injected Provider - MetaMask`;
    - в MetaMask переключиться на:
      - **Base Sepolia** для тестовой сети;
      - **Base mainnet** для боевой сети.
  - Деплой:
    - выбрать контракт в списке, нажать Deploy, подтвердить транзакцию в MetaMask;
    - записать адрес контракта и network (Sepolia/mainnet).
- **После деплоя**:
  - Верифицировать контракт на BaseScan (Sepolia или mainnet):
    - указать **точно те же** версию компилятора и настройки оптимизации;
    - приложить исходники.
  - Обновить конфиг приложения:
    - `NEXT_PUBLIC_COOKIEJAR_ADDRESS_SEPOLIA` / `NEXT_PUBLIC_COOKIEJAR_ADDRESS_MAINNET` (или аналогичные переменные);
    - логику в `app/contract.ts`, которая выбирает адрес по `NEXT_PUBLIC_BASE_NETWORK`.
- **Типичные ошибки**:
  - Деплой в неправильную сеть (Sepolia vs mainnet) из‑за неправильного выбора сети в MetaMask.
  - Несовпадение версии компилятора/оптимизации между Remix и верификацией на BaseScan.
  - Обновление адреса контракта только в env, но не в paymaster‑allowlist → транзакции начинают падать на новом контракте.

---

### 2. Редкости, pity-таймер и сеты коллекций

- **Концепция из `based-cookie-gamification-ideas.md`**:
  - каждая фортуне имеет `rarity: 'common' | 'rare' | 'legendary'`;
  - у пользователей есть:
    - счётчики по редкостям;
    - прогресс по сетам;
    - pity-таймеры (гарантированные редкие/легендарные фортуны после N клеймов без успеха).
- **Backend-реализация**:
  - Расширить `FortuneDefinition`:
    - `rarity`, `setId`, возможно дополнительные поля (например, "season", "event").
  - В `POST /api/fortune/claim`:
    - бизнес-логика выбора фортуны может учитывать pity-таймеры;
    - при выдаче редкой/легендарной фортуны обнулять соответствующие `claimsSinceLastRare/Legendary`.
  - В `UserStats`:
    - добавить/актуализировать поля:
      - `rareClaims`, `legendaryClaims`;
      - прогресс по сетам (может быть в отдельной таблице/модели).
- **UI**:
  - На главной странице:
    - бейджи редкости (цвета, иконки, анимации);
    - прогрессбар pity-таймера ("ещё X клеймов до гарантированной редкой фортуны").
  - В истории:
    - визуальная группировка по редкостям/сетам;
    - фильтры по редкости.
- **Типичные ошибки**:
  - **Слишком тяжёлая логика на фронте**:
    - выбор фортуны и редкости должен, по возможности, происходить на backend/контракте;
    - фронтенд не должен "угадывать" результат, только отображать.
  - **Непрозрачные вероятности**:
    - если шансы на редкости меняются, важно зафиксировать это в коде/конфиге, а не "раскидать" магические числа.

---

### 3. NFT-сувениры по фортунам

- **Пользовательский сценарий**:
  - в истории фортуны пользователь выбирает любимую/редкую фортуне;
  - нажимает "заминтить" → создаётся NFT с текстом, редкостью, датой, опционально streak/сет.
- **Ончейн-часть**:
  - контракт:
    - должен иметь метод `mintFortuneNft(...)` с параметрами, достаточными для формирования метаданных;
    - может кодировать часть данных в токене (tokenURI или on-chain metadata).
  - метаданные:
    - JSON, содержащий:
      - текст фортуны;
      - редкость;
      - дату клейма;
      -, возможно, streak/сет.
- **Backend**:
  - Эндпоинт, например, `POST /api/nft/mint-fortune`:
    - принимает `claimId` и/или `fortuneId`;
    - проверяет, что пользователь имеет право минтить (это его клейм, не превышен лимит и т.п.);
    - подготавливает данные для транзакции (`to`, `data`, `value`) по контракту;
    - возвращает их в формате, совместимом с OnchainKit `Transaction`/`TransactionButton`.
- **Фронтенд**:
  - В `app/history/page.tsx`:
    - кнопка "заминтить" для записей с подходящей редкостью;
    - flow аналогичен текущему клейму награды:
      - `Transaction` + `TransactionButton` с onchain-вызовом;
      - `handleTxStatus`/нотификации.
- **Типичные ошибки**:
  - **Смешивание ответственности**:
    - не стоит дублировать mint-логику частично в контракте, частично в backend;
    - backend должен только подготавливать call data, а всю бизнес-логику консистентно реализовывать либо в контракте, либо в одной серверной функции.
  - **Неверная проверка прав**:
    - нельзя позволять минтить NFT по чужой фортуне (другого пользователя);
    - нужно проверять и FID, и адрес, и принадлежность `claimId`.

---

### 4. Расширенные лидерборды и ачивки

- **Новые метрики**:
  - количество NFT-сувениров;
  - число завершённых сетов;
  - редчайшие полученные фортуны;
  - "длина" pity-таймера (сколько клеймов понадобилось до первой редкой фортуны).
- **Backend**:
  - можно добавить новые `metric` значения в `GET /api/leaderboard`;
  - либо ввести отдельный эндпоинт `/api/leaderboard/advanced`.
  - использовать агрегаты по NFT и сетам.
- **UI (`app/leaderboard/page.tsx`)**:
  - дополнительные вкладки;
  - ачивки/бейджи рядом с пользователями.
- **Типичные ошибки**:
  - **Слишком тяжёлые запросы**:
    - advanced-лидерборды могут быть дорогими;
    - лучше заранее продумать precompute (cron/jobs) и кэширование.

---

### 5. Интеграция с AgentKit-подпримером

- **Исходная точка**:
  - В репо уже есть подпример:
    - `Based Cookie/app/page.tsx`;
    - `Based Cookie/app/api/agent/prepare-agentkit.ts`.
- **Цель**:
  - из `app/page.tsx` добавить flow "Поговорить с печенькой-агентом", который:
    - открывает агентский UI внутри мини-аппа;
    - позволяет пользователю запрашивать дополнительные on-chain-действия (донат, своп, управление NFT).
- **Технические нюансы**:
  - Навигация:
    - вариант A: встраивание AgentKit UI в модальное окно/отдельный экран в том же приложении;
    - вариант B: переход в под-приложение (с учётом Mini App-ограничений).
  - Авторизация:
    - убедиться, что AgentKit использует те же FID/адреса, что и основной flow;
    - избегать расхождений в wallet-контексте (OnchainKit vs Smart Wallet от CDP).
- **Безопасность и UX**:
  - Агент должен:
    - явно пояснять, какие действия он собирается сделать (суммы, токены, адреса);
    - максимально использовать уже привычный пользователю интерфейс транзакций (OnchainKit/Wallet UI).
- **Типичные ошибки**:
  - **Разрыв состояния между основным приложением и AgentKit**:
    - например, пользователь видит одну фортуне/адрес в основном UI, а в агенте оперирует другим адресом;
    - важно централизованно хранить/передавать контекст пользователя.

---

## Чего не делать на этапе 3

- **Не менять без крайней нужды уже опубликованные API-контракты**:
  - если нужно расширить ответы — добавлять новые поля, не ломая старые;
  - при необходимости полностью другого контракта — вводить `/api/v2/...`.
- **Не разворачивать сразу сложные прод-системы без мониторинга**:
  - NFT-минт и ончейн-редкости должны сопровождаться:
    - логированием;
    - алертингом;
    - возможностью временно отключить отдельные фичи (feature flags).

---

## Подсказки, если появятся запросы "вне плана"

- **Если попросят "просто поменять контракт и сразу выкатить"**:
  - нужно явно проговорить риски:
    - несовместимость ABI;
    - отвалившиеся paymaster/allowlist;
    - возможная потеря стейт-мэппинга между старым и новым контрактами.
- **Если попросят "сделать своп/донат" прямо с главной страницы**:
  - лучше маршрутизировать такие действия через AgentKit:
    - он уже спроектирован для сложных сценариев;
    - можно повторно использовать action providers и Smart Wallet.

---

## Краткий чеклист перед merge этапа 3

- **Контракт**:
  - ABI и адрес совпадают между деплоем и `app/contract.ts`;
  - paymaster-allowlist обновлён и протестирован.
- **NFT и редкости**:
  - NFT-минт работает end-to-end (UI → backend → контракт → отображение токена);
  - редкости корректно учитываются в статистике и лидербордах.
- **AgentKit**:
  - агент видит корректный контекст пользователя (FID, адрес, историю фортуны);
  - все ончейн-действия через агента прозрачны и безопасны для пользователя.

